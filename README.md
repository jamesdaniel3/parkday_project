# How To Run The Project

To build and run project in XCode:

```bash
npx expo run:ios
```

The backend is hosted on Google Cloud and all the API calls in the frontend are currently pointed to the hosted server, so you don't need to launch the server.

# Project Overview

For this project, I built the frontend in React-Native which I generated the boilerplate for with Expo. As requested, I built the backend in Node JS along with Koa and Knex.

### Backend Design

A large focus of mine when building this project was creating a backend that I thought could be scalable and maintable. The only backend-related choice that I made to the contrary was writing the backend if JavaScript instead of TypeScript. While I am comfortable writing code in TypeScript, I was having too many issues with the config files when setting up the backened intially to justify the time sink that would come with contuing to use TypeScript. I opted to use JavaScript for the increased speed of developement, given the scope of the project.

The backend is hosted on Google Cloud Run and connected to a PostgreSQL instance in Google Cloud SQL. All of the API calls in the React-Native app point to the production endpoints. While this would not be the ideal choice for working in a project that is going to be released, it could easily be fixed by adding an environment variable which is used to set the base URL of the API calls. I chose to use the hosted endpoints because it removes the need to launch the backend when testing and I wanted to show that the backend could be used in a production environment, as I believe that setting up and deploying a server is a skill in itself.

When writing API endpoints for the first time or making migrations to the database, I would launch the server locally and first test the endpoints and the migrations against a local PostgreSQL instance.

The backend is containerized with Docker for the sake of deploying on Google Cloud. When I want to push updates to the Google Cloud deployed server, I run the bash script `gcloud_backend_deploy.sh`. When I want to run the server locally, I just run:

```bash
cd server
node server.js
```

The last notable feature of the backend was the use of migrations through Knex. After setting up connections to my produciton and development PostgreSQL instances, I needed to create the columns and tables of my database. I could have done this manually through a GUI or CLI for both instances, but I chose to set up migrations as I would want to have them on a larger project. They allow for version control within the database and provide a log of all changes made to the database over time.

To create a migration:

```bash
npm run make:migration -- comment_name
```

After writing the migration file, you can run the migration with the following:

```bash
npm run migrate:dev
```

Then, the bash script will force the migraitons to be made when deploying the backend to google cloud.

### Database Design

![Database Diagram](/DatabaseDiagram.png)

Above is a diagram visualizing the structure of my database. The most notable departures from a basic database design for a project like this are the `operating_hours` and `menu_availabilty` tables. I built these tables to handle restaurants serving different menus on different days and times and to handle restaurants having different operating hours on different days. They add some complexity to the queries taht need to be written and are probably not worth the cost with the project at this scale, but I beleive these tables or some other solution would be entirely necessary in a version of this project operating at a greater scale.

Not shown in the diagram are the knex_migrations and knex_migrations_lock tables that are generated by knex to maintain the version history of the tables. Additionally, every table has a column labeled created_at and a column labeled updated_at to keep track of the age of the data. This would be useful if we ever needed to do a role back or edit data from a certain period of time.

### Frontend Design

When designing the frontend, I wanted to integrate as many of the frames shown on the given Figma as possible. When looking to see how the frames might work together, I thought it made the most sense for the app to have two screens, at least to start.

The first screen holds all of the restaurants that are currently open. If you click on any of the restaurants, then all of the items that they are currently serving appear.

The UI is currently fairly simple, and I just focused on making the cleanest and most usable UI I could. There are many features that could be added which I will discuss below.

### Scraper Design

# Future Roadmap

If I were to continue devleoping this project, here are a few of the changes I would like to make/features I would like to add.

#### Searchability

I would like to add a search bar on both the homescreen and a menu screen to allow users to more effectively find restaurants or meals that they want.

#### Admin Dashboard for Adding Website Info

I was not able to find an AI tool that was super effective at scraping the many different websites structures that different restaurants use. I think the best solution would be to build out a dashboard where a useer can provide a link to the restaurant's website along with either a link to their menu or a file containing their menu. AI tools can then be used to generate as much information as possible about the restaurant and the users can quickly fact check the data or add anything that they would like.

I built out most of this logic in my scraper, but I would definitely like to build a UI for it to minimize the technical barrer-to-entry for users.

#### Checkout

I would like to add a checkout feature, as referenced in Figma by the "Reserve this lunch" Frame. This is quite a big feature and if it were to be integrated fully, we would have a working app where users could order food.
